# 分布式锁
#### redis的分布式锁——RedLock算法
这个场景假设有一个redis集群，然后有多个redis master，它们通常会执行以下步骤获取一把锁；
1. 获取当前的时间戳，毫秒
2. 尝试在每个master上面加锁，设置过期时间
3. 客户端计算建立锁的时间，如果小于过期时间，则成功
4. 要是建立失败，就把之前建立过的锁删掉
5. 只要有节点成功建立了一把分布式锁，你就不断轮询地去尝试获取这把锁。


#### zk分布式锁
某个节点尝试创建==临时 znode==，此时创建成功了就获取了这个锁。
这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。
> 其实还有另外一种说法，那就是每个要获取锁的客户端都尝试建立一个node，node小的那个客户端获取这把锁

# 分布式事务

#### 两阶段提交
两阶段提交也就是说：有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。

但是这种方式，比较适合单块应用里，跨多个库的分布式事务。但是他非常严重依赖于数据库层面，所以效率很低，不太适用于高并发的场景。

#### TCC方案
Try阶段：这个阶段说的是对各个服务器的资源做检测以及对资源进行锁定或者预留。

Confirm阶段：这个阶段说的是各个服务中执行实际的操作。

Cancel阶段：任何一个服务的业务方法出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。

这种方案用的几乎比较少，因为这种方式的事务回滚实际上是严重依赖于自己写代码来进行逻辑的回滚操作。一般来说，跟钱，支付相关的，我们会用TCC这种场景。

#### 可靠消息最终一致性
直接使用MQ来实现事务 ，这是比较常用的一种方式
1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。
![image](https://ask.qcloudimg.com/http-save/yehe-1258501/a969wp2oxc.png)

