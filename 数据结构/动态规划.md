# 动态规划
先引入一个简单的问题：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```
分析：令f(i) := 在第i天卖出股票所得到的收益，则我们只需求出max(f(i))即可。
易推出 f(i) = max(f(i-1) + prices[i] - prices[i-1], prices[i] - prices[i-1])，
即 f(i) = max(f(i-1),0) + prices[i] - prices[i-1].

由此可写出python3代码：
def maxProfit(self, prices: List[int]) -> int:
        '''
        max = 0
        length = len(prices)
        for i in range(length-1):
            for j in range(i+1,length):
                if prices[j]-prices[i] > max:
                    max = prices[j]-prices[i]
        return max
        '''
        if len(prices) == 0: return 0
        max_f = 0
        pre_f = 0
        for i in range(1,len(prices)):
            pre_f = max(pre_f,0) + prices[i] - prices[i-1]   #  pref 表示股票赚的钱 顶多就是不赚不亏为0，总之不能为负数。目的就是要构造最大的pj - pi
            max_f = max(max_f,pre_f)
        return max_f

```

## 递推关系的动态规划
如果一个算法的条件存在递推关系，那么可以采用动态规划来解决。就像泰波那契数的边界条件。找到**边界条件**，然后动态滚动，这就是动态规划.
这就要求我们要保留计算的中间结果，最简单的就是用数组保存。这是递归方式的一种优化。

### 要尽可能的转移成数学问题，例如：
给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。
这道题就暗示我们，每一次都要尽可能的跳的最远，这样才会用最少的跳跃次数到达最后的位置。![跳的最远](https://pic.leetcode-cn.com/1631454173-gIrMFv-image.png)如图所示，当我们处于A点，A可以跳到BCDF。
我们按照跳的最远的选的话，可以选CD。
但是因为本身D就比C远一个距离所以下一次跳的位置是D。

关键在于记录位置信息！！！！

```
##  cnt：我们跳了几次
##  cur：当前位置是在哪里
##  tmp_max：下一次可以跳到的最远距离
## nex:下一次的index
class Solution(object):
    def jump(self, nums):
        if len(nums) == 1: return 0 # 特殊0
        cnt, cur, n = 0, 0, len(nums)
        while cur < n:
            tmp_max,nex = -1,None
            for i in range(cur+1, cur+1+nums[cur]):# 总能到达最后一个 所以i肯定不会是0
                if i >= n-1: return cnt+1 # 注意这里下一次跳的范围内可以就达到最后一个点了，直接返回输出。
                if nums[i] + i >= tmp_max:
                    tmp_max = nums[i] + i
                    nex = i
            cur = nex
            cnt += 1
            if cur >= n-1:
                break
        return cnt          


```

其实大多数的动态规划问题都可以通过贪心策略进行解决。贪心策略允许我们不从整体最优上加以考虑，他所得到的只是某种意义上的局部最优解。


分治法主要是考虑将一个问题拆分成多个相似的小问题，分别对这些小问题进行求解，如果拆分出的问题依旧复杂，那就通过**递归调用**继续讲子问题拆分。直到拆分后的问题可以用简单的方式来求解。


！！！有时候要注意**数形结合**的用法！！！！


### 若没有递推公式等，要学会转化，变成找当前元素的最大值/最小值问题
例如 求最大乘积子数组：
用动态规划的思想：我们需要记录前i的乘积的**最大值**跟**最小值**，然后将他跟当前元素的乘积来进行比较。即dp[i] = max(nums[i] * pre_max, nums[i] * pre_min, nums[i]), 这里0 不需要单独考虑, 因为当相乘不管最大值和最小值,都会置0
'''
if not nums: return 
        res = nums[0]
        pre_min = nums[0] ### 前i个的最小值
        pre_max = nums[0] ### 前i个的最大值
        for i in range(1,len(nums)):
            cur_max = max(pre_min*nums[i],pre_max*nums[i],nums[i])  
            cur_min = min(pre_min*nums[i],pre_max*nums[i],nums[i])
            res = max(cur_max,res)
            pre_max = cur_max
            pre_min = cur_min

        return res
'''

## 有时候还需要分析下  存在的几种状态。