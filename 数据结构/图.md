# 图的存储结构

> 由于图的任意两个顶点间都可能存在联系，因此无法像链表或者二叉树那样事先在内存中定义元素来实现这种数据结构，但是图是由顶点跟边两部分组成，所以我们考虑用邻接矩阵来实现

### 邻接矩阵
图的邻接矩阵存储方式是用两个数组来表示图。一个**一维数组存储顶点**信息，一个**二维数组存储边**的信息。这个二维数组又称为邻接矩阵。矩阵值为大于1的点，说明这两个顶点之间有边相连。若大于1，则表示边的权值。无向图的邻接矩阵是对称的。
![image](http://blog.chinaunix.net/attachment/201301/28/26548237_1359358929SkA2.png)
出现了无穷，则是对于有向图而言，反向边就为无穷。

### 图的一些定义
1. 如果图中任意两个顶点都可达，则该图是连通的，称为连通图。
2. 无向图中，任意两个顶点都存在边，则称该图是无向完全图。有向图中任意两个顶点都存在相反方向的两个边，则为有向完全图。
3. 无向图的顶点的边数，称为顶点的度，有向图分为出度跟入度。
4. 

### 代码实现
 ##### 图的定义
```
typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef char VertexType; /* 顶点类型应由用户定义  */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */
typedef struct
{
	VertexType vexs[MAXVEX]; /* 顶点表 */
	EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */
	int numNodes, numEdges; /* 图中当前的顶点数和边数  */
}MGraph;
```
在对边数进行赋值权值操作的时候，要考虑到无向图的邻接矩阵是对称的。

> 这种方式如果对于顶点数跟边数较少的情况会存在很大的空间浪费，因为需要预先定义数组的大小。既然如此不如用链式的方式去动态分配空间大小，所以引入了另外一种方式：邻接表。

### 邻接表
1.图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过，数组可以较容易的读取顶点的信息，更加方便。<br>2. 图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以，用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。
![image](http://blog.chinaunix.net/attachment/201301/28/26548237_1359371746DDZF.png)

#### 代码实现
```
typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码,如OK等 */
typedef char VertexType; /* 顶点类型应由用户定义 */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct EdgeNode /* 边表结点  */
{
	int adjvex;    /* 邻接点域,存储该顶点对应的下标 */
	EdgeType info;		/* 用于存储权值,对于非网图可以不需要 */
	struct EdgeNode *next; /* 链域,指向下一个邻接点 */
}EdgeNode;

typedef struct VertexNode /* 顶点表结点 */
{
	VertexType data; /* 顶点域,存储顶点信息 */
	EdgeNode *firstedge;/* 边表头指针 */
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList; 
	int numNodes,numEdges; /* 图中当前顶点数和边数 */
}GraphAdjList;
```
顶点指向边表结点，来标注顶点跟边的关系。以上代码的节点是用一个结构体数组来存储，其实也可以用一个链表的形式存储，此时的顶点结构体要加一个next指针域，不过一般都采用数组的形式，方便访问，但是要视具体情况来选择。

### 十字链表（有向图）
上面讲的都是对于无向图而言，若是用到有向图，则就复杂很多，有时候需要遍历整个图才能知道。这时候图就应该换一种方式去存储，十字链表就应运而生了。因为有向图分出度跟入度，用邻接表不好实现，而十字链表不同，十字链表刚好有两个指针域，分别指向出入度。

#### 结构定义如
顶点表结构如下：<br>
![image](http://blog.chinaunix.net/attachment/201301/28/26548237_1359379404626B.png)<br>
其中firstin表示**入==边表==头指针**，（入度）指向该顶点的入边表中第一个结点，firstout表示出边表头指针（出度），指向该顶点的出边表中的第一个结点。
边表结构如下：<br><br>
![image](http://blog.chinaunix.net/attachment/201301/28/26548237_1359379502NBBu.png)<br>
其中，tailvex是指弧起点在==顶点表==的下表，headvex是指弧终点在顶点表的下标，**headlink是指入==边表==指针域**，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以增加一个weight域来存储权值。
具体情况如下图：
![image](http://blog.chinaunix.net/attachment/201301/28/26548237_1359379826wexn.png)
重点需要解释虚线箭头的含义。它其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此的firstin指向顶点v1的边表结点中headvex为0的结点，如上图圆圈1。接着由入边结点的headlink指向下一个入边顶点v2，如上图圆圈2。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如上图圆圈3。

### 邻接多重表(优化无向图的结构，方便对无向图的边进行操作)
将顶点、边分开表示，一个边表节点表示一条边。

## 图的遍历
图的遍历和树的遍历类似，希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。避免回路陷入死循环。
==防止循环访问的情况==
>在遍历时，如果沿着图存在回路，那沿着某个顶点出发会回到原地，这样就造成了有些顶点没有访问到的情况，这时候，就需要我们设计一个==访问数组==，统计访问过的顶点。初值为0，访问过的就为1。

遍历分为深度优先遍历跟广度优先遍历
### 深度优先遍历（DFS）
深度优先遍历，又称为深度优先搜索。类似于一棵树的前序遍历，先遍历左子结点。
##### 定义
它从图中某个结点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中的所有顶点都被访问到为止。

#### 伪代码思路
1. 访问数组初始化：visited[n] = 0
2. 访问顶点：visited[v] = 1
3. 取v的第一个邻接点w；
```
4. 循环递归：
    while(w存在)
        if(w未被访问过)
            从顶点w出发递归执行;
        w = v的下一个邻接点;
```
5. 非递归实现
```
1. 栈初始化：visited[n] = 0
2. 访问顶点：visited[v] = 1
3. 入栈
4. while(栈不为空)
    x = 栈的顶元素，并且出栈;
    if (存在并找到未被访问的x的邻接点w)
        访问w：visited[w] = 1
        w进栈
```
#### 代码实现
代码形式，是依此访问某个结点邻接结点中，数值小的，以此进行遍历。或者以此访问临近的指针域，依次便利。
---

邻接矩阵的方式
```
Boolean visited[MAXVEX]; /* 访问标志的数组 */

/* 邻接矩阵的深度优先递归算法 */
void DFS(MGraph G, int i)
{
	int j;
 	visited[i] = TRUE;
 	printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */
	for(j = 0; j < G.numVertexes; j++)
		if(G.arc[i][j] == 1 && !visited[j])
 			DFS(G, j);/* 对为访问的邻接顶点递归调用 */
}

/* 邻接矩阵的深度遍历操作 */
void DFSTraverse(MGraph G)
{
	int i;
 	for(i = 0; i < G.numVertexes; i++)
 		visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
	for(i = 0; i < G.numVertexes; i++)
 		if(!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ 
			DFS(G, i);
}
```
邻接表的形式
```
Boolean visited[MAXSIZE]; /* 访问标志的数组 */

/* 邻接表的深度优先递归算法 */
void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
 	visited[i] = TRUE;
 	printf("%c ",GL->adjList[i].data);/* 打印顶点,也可以其它操作 */
	p = GL->adjList[i].firstedge;
	while(p)
	{
 		if(!visited[p->adjvex])
 			DFS(GL, p->adjvex);/* 对为访问的邻接顶点递归调用 */
		p = p->next;
 	}
}

/* 邻接表的深度遍历操作 */
void DFSTraverse(GraphAdjList GL)
{
	int i;
 	for(i = 0; i < GL->numVertexes; i++)
 		visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */
	for(i = 0; i < GL->numVertexes; i++)
 		if(!visited[i]) /* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */ 
			DFS(GL, i);
}
```
对比两个不同的存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找某个顶点的邻接点需要访问矩阵中的所有元素，因为需要O(n2)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。

### 广度优先遍历
选定某个结点，当根节点，放第一层，让与他有边的结点放第二层，再让与第二层有边相接的节点放第三层，依次往下类推。（考虑连通图的情况，存在散点，暂不做讨论）

##### 定义
广度优先遍历，又称为广度优先搜索，简称BFS。图的广度优先遍历就类似于树的层序遍历了。

#### 伪代码实现
非递归的形式，用队列，所以没法 递归。若是逻辑上类似于栈的数据结构形式，则可以考虑采用递归的方式实现。
```
1. 初始化队列：visited[n] = 0
2. 访问顶点：visited[v] = 1
3. 顶点v加入队列
4. 循环：
    while(队列是否为空)
        v = 队列头元素
        w = v的第一个邻接点
        while(w存在)
            if(如果w未访问)
                visited[w] = 1;
                顶点w加入队列
                w = 顶点v的下一个邻接点
```

#### 代码实现
具体实现是需要使用队列来操作，队列先进先出的数据结构。将同一层的结点放在同一个队列中。结点遍历出队列，就把跟这个结点有相接的结点入队列，依次循环即可。
邻接矩阵
```
/* 邻接矩阵的广度遍历算法 */
void BFSTraverse(MGraph G)
{
	int i, j;
	Queue Q;
	for(i = 0; i < G.numVertexes; i++)
       	visited[i] = FALSE;
    InitQueue(&Q);		/* 初始化一辅助用的队列 */
    for(i = 0; i < G.numVertexes; i++)  /* 对每一个顶点做循环 */
    {
		if (!visited[i])	/* 若是未访问过就处理 */
		{
			visited[i]=TRUE;		/* 设置当前顶点访问过 */
			printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */
			EnQueue(&Q,i);		/* 将此顶点入队列 */
			while(!QueueEmpty(Q))	/* 若当前队列不为空 */
			{
				DeQueue(&Q,&i);	/* 将队对元素出队列，赋值给i */
				for(j=0;j<G.numVertexes;j++) 
				{ 
					/* 判断其它顶点若与当前顶点存在边且未访问过  */
					if(G.arc[i][j] == 1 && !visited[j]) 
					{ 
 						visited[j]=TRUE;			/* 将找到的此顶点标记为已访问 */
						printf("%c ", G.vexs[j]);	/* 打印顶点 */
						EnQueue(&Q,j);				/* 将找到的此顶点入队列  */
					} 
				} 
			}
		}
	}
}
```

邻接表
```
/* 邻接表的广度遍历算法 */
void BFSTraverse(GraphAdjList GL)
{
	int i;
    EdgeNode *p;
	Queue Q;
	for(i = 0; i < GL->numVertexes; i++)
       	visited[i] = FALSE;
    InitQueue(&Q);
   	for(i = 0; i < GL->numVertexes; i++)
   	{
		if (!visited[i])
		{
			visited[i]=TRUE;
			printf("%c ",GL->adjList[i].data);/* 打印顶点,也可以其它操作 */
			EnQueue(&Q,i);
			while(!QueueEmpty(Q))
			{
				DeQueue(&Q,&i);
				p = GL->adjList[i].firstedge;	/* 找到当前顶点的边表链表头指针 */
				while(p)
				{
					if(!visited[p->adjvex])	/* 若此顶点未被访问 */
 					{
 						visited[p->adjvex]=TRUE;
						printf("%c ",GL->adjList[p->adjvex].data);
						EnQueue(&Q,p->adjvex);	/* 将此顶点入队列 */
					}
					p = p->next;	/* 指针指向下一个邻接点 */
				}
			}
		}
	}
}
```
对比图的深度优先遍历与广度优先遍历算法，会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点的访问顺序不同。可见两者在全图遍历上是没有优劣之分的，只是不同的情况选择不同的算法。

#### 优缺点分析
深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时，找到最优解的情况。

## 最小生成树
> 针对于带权图而言，即是用这个图，构造权值最小的连通网（带权连通图）

图的生成树是它的一颗含有其所有顶点的无环连通子图,一幅加权图的最小生成树(MST)是它的一颗权值(树中的所有边的权值之和)最小的生成树

### 普里姆（Prim）算法
>它的每一步都为树添加一条边.每一次都将下一条连接树中的顶点和不在树中的顶点且权重最小的边加入树中。

先构造成一个边的**邻接矩阵**。
然后选择一个顶点，放入顶点数组然后选择与这个顶点数组中的顶点相接最小权值的边，并把这条边对应的另一个顶点加入到顶点数组中。继续重复上述过程循环。<br>
**注意:** 要防止这个连通图陷入循环.

#### 代码如下：
```
/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph G)
{
	int min, i, j, k;
	int adjvex[MAXVEX];		/* 保存相关顶点下标 */
	int lowcost[MAXVEX];	/* 保存相关顶点间边的权值 */
	lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
			/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
	adjvex[0] = 0;			/* 初始化第一个顶点下标为0 */
	for(i = 1; i < G.numVertexes; i++)	/* 循环除下标为0外的全部顶点 */
	{
		lowcost[i] = G.arc[0][i];	/* 将v0顶点与之有边的权值存入数组 */
		adjvex[i] = 0;					/* 初始化都为v0的下标 */
	}
	for(i = 1; i < G.numVertexes; i++)
	{
		min = INFINITY;	/* 初始化最小权值为∞， */
						/* 通常设置为不可能的大数字如32767、65535等 */
		j = 1;k = 0;
		while(j < G.numVertexes)	/* 循环全部顶点 */
		{
			if(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */
			{	
				min = lowcost[j];	/* 则让当前权值成为最小值 */
				k = j;			/* 将当前最小值的下标存入k */
			}
			j++;
		}
		printf("(%d, %d)\n", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */
		lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */
		for(j = 1; j < G.numVertexes; j++)	/* 循环所有顶点 */
		{
			if(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) 
			{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
				lowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
				adjvex[j] = k;				/* 将下标为k的顶点存入adjvex */
			}
		}
	}
}
```
由算法代码中的循环嵌套可得知此算法的时间复杂度为O[N^2];

### 克鲁斯卡尔（Kruskal）算法
Kruskal算法的思想按照边的权重顺序从小到大处理它们,然后将边按照从小到大的次序加入到最小生成树中,加入的边不会和已经加入的边构成环,直到树中含有v-1条边为止。<br>
**注意：** 这个算法要判断选择的边是否会构成环。要是整个数的权值最小，整个连通网的权值最小，就一定不可以生成环。

#### 代码如下：
```
/* 生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
	int i, j, n, m;
	int k = 0;
	int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */
	
	Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */

	/* 用来构建边集数组并排序********************* */
	for ( i = 0; i < G.numVertexes-1; i++)
	{
		for (j = i + 1; j < G.numVertexes; j++)
		{
			if (G.arc[i][j]<INFINITY)
			{
				edges[k].begin = i;
				edges[k].end = j;
				edges[k].weight = G.arc[i][j];
				k++;
			}
		}
	}
	sort(edges,&G);//由小到大，对图的边集数组进行排序
	/* ******************************************* */


	for (i = 0; i < G.numVertexes; i++)
		parent[i] = 0;	/* 初始化数组值为0 */

	printf("打印最小生成树：\n");
	for (i = 0; i < G.numEdges; i++)	/* 循环每一条边 */
	{
		n = Find(parent,edges[i].begin);
		m = Find(parent,edges[i].end);
		if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */
		{
			parent[n] = m;	/* 将此边的结尾顶点放入下标为起点的parent中。 */
							/* 表示此顶点已经在生成树集合中 */
			printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
		}
	}
}

/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)
{
	while ( parent[f] > 0)
	{
		f = parent[f];
	}
	return f;
}/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)
{
	while ( parent[f] > 0)
	{
		f = parent[f];
	}
	return f;
}
```
上述代码，用了一个parent数组来判断是否形成回路。
边集数组edges中的边集顺序是**按小到大**排列的。
对权值进行大小排序的代码较简单，这里省略。