# 快速排序
快速排序是基于分治法的思想，要注意区分希尔排序，希尔排序是进行分组，而快速排序是基于的分治法的交换排序。
> 分治法：把规模为n的输入分割成k个子集，产生l个子问题，分别求解得到l个子问题的解，并将子解组合成原问题的解。
### 过程

1. 在数据集之中，选择一个元素作为”基准”（pivot）。
2. 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。
3. 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
4.
**注：** 在严蔚敏书中一般将第一个元素当成基准元素。
快速排序的主要过程就是==挖坑填数==。（low与high进行交换也可以）

## 详解
1.如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾
![image](https://img-blog.csdn.net/20180910121224126?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
2. 首先从后半部分开始，如果扫描到的值大于基准数据就让high减1,如果发现有元素比该基准数据的值小(如上图中18<=tmp)，就将high位置的值赋值给low位置 ,结果如下: 
![image](https://img-blog.csdn.net/20180910121350322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
3. 然后开始从前往后扫描,如果扫描到的值小于基准数据就让low加1,如果发现有元素大于基准数据的值(如上图46=>tmp)，就再将low位置的值赋值给high位置的值,指针移动并且数据交换后的结果如下: ![image](https://img-blog.csdn.net/20180910121503615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
4. 然后再开始从后向前扫描,原理同上,发现上图11<=tmp,则将low位置的值赋值给high位置的值,结果如下:![image](https://img-blog.csdn.net/20180910121538339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
5. 然后再开始从前往后遍历,直到low=high结束循环,此时low或high的下标就是基准数据23在该数组中的正确索引位置.如下图所示. ![image](https://img-blog.csdn.net/20180910121618344?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25yc2MyNzI0MjAxOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
这样一遍走下来,可以很清楚的知道,其实快速排序的本质就是把基准数大的都放在基准数的左边,把比基准数小的放在基准数的右边,这样就找到了该数据在数组中的正确位置. 
> ①先从队尾开始向前扫描且当low < high时,如果a[high] > tmp,则high–,但如果a[high] < tmp,则将high的值赋值给low,即arr[low] = a[high],同时要转换数组扫描的方式,即需要从队首开始向队尾进行扫描了 
  ②同理,当从队首开始向队尾进行扫描时,如果a[low] < tmp,则low++,但如果a[low] > tmp了,则就需要将low位置的值赋值给high位置,即arr[low] = arr[high],同时将数组扫描方式换为由队尾向队首进行扫描. 
  ③不断重复①和②,知道low>=high时(其实是low=high),low或high的位置就是该基准数据在数组中的正确索引位置.
