# 树
## 二叉树
##### 定义
二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>

##### 实例

![image](https://images.cnblogs.com/cnblogs_com/ajayumi/ProgramImage/2009050402.jpg)

#### 满二叉树跟完全二叉树
满二叉树的性质：
- 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;
- 叶子数为2h;
- 第k层的结点数是：2k-1;
- 总结点数是：2k-1，且总节点数一定是奇数。
- 满二叉树一定是完全二叉树
<br>

完全二叉树：<br>
若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到**最大个数**，第h层所有的结点都连续集中在**最左边**，这就是完全二叉树。
> 注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

![image](https://images0.cnblogs.com/i/595738/201403/141749056837546.png)

### 二叉树的性质
1.  在非空二叉树中，第i层的结点总数不超过2^i-1, i>=1;

2. 深度为h的二叉树最多有2h-1个结点(h>=1)，最少有h个结点;
3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;
4.  具有n个结点的完全二叉树的深度为log2(n+1);
5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：若I为结点编号则如果I>1，则其父结点的编号为I/2（整除，向下取整。即5/2=2）；
- 如果2I<=N，则其左儿子（即左子树的根结点）的编号为2I；若2I>N，则无左儿子；
- 如果2I+1<=N，则其右儿子的结点编号为2I+1；若2I+1>N，则无右儿子。
6. 给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。
7. 设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。

##### 二叉树的遍历操作（一般采用递归）
- 前序遍历
先访问根结点，然后前序遍历左子树，然后遍历右子树。（根左右）
```
//以c语言代码为例子
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    printf("%c",T->data);//对树的根节点的操作
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}
```
- 中序遍历
中序遍历先访问树的左子树，然后访问根节点，最后中序遍历右子树。
```
//以c语言代码为例子
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    PreOrderTraverse(T->lchild);
    printf("%c",T->data);//对树的根节点的操作
    PreOrderTraverse(T->rchild);
}
```
- 后序遍历
从左到右，先叶子后节点的方式遍历访问左子树，右子树，最后访问根节点。
```
//以c语言代码为例子
void PreOrderTraverse(BiTree T){
    if(T==NULL){
        return;
    }
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
    printf("%c",T->data);//对树的根节点的操作
```

- 层序遍历
根结点开始访问，从上往下，逐层访问、遍历。在同一层中，按从左到右的顺序对结点逐个访问。（平时用的较少）

> 注：已知前序遍历序列和==中序遍历==序列可以唯一确定一棵二叉树。
已知后续遍历序列和==中序遍历==序列，可以唯一确定一棵二叉树。



### 二插排序树
这仍是一棵二叉树，并且在具备二叉树的基础上还具备以下性质：
- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也是二插排序树
- 没有相等的节点
- 对这棵二叉排序树进行中序遍历可以得到有序的序列

##### 二叉排序树的操作
> 时间复杂度与二分查找法的时间复杂度差不多一致。

插入过程:
1. 若当前二叉树为空，则插入元素为根节点
2. 若插入元素小于根节点，则将元素插到左子树上去
3. 若插入元素大于根节点，则将元素插到右子树上去。<br>
插入代码：
```
struct node
{
    int val;//结点的值
    pnode lchild;
    pnode rchild;
};

pnode BT = NULL;


//递归方法插入节点 
pnode insert(pnode root, int x)
{
    pnode p = (pnode)malloc(LEN);
    p->val = x;
    p->lchild = NULL;
    p->rchild = NULL;
    if(root == NULL){
        root = p;    
    }    
    else if(x < root->val){
        root->lchild = insert(root->lchild, x);    
    }
    else{
        root->rchild = insert(root->rchild, x);    
    }
    return root;
}

//非递归方法插入节点 
void insert_BST(pnode q, int x)
{
    pnode p = (pnode)malloc(LEN);
    p->val = x;
    p->lchild = NULL;
    p->rchild = NULL;
    if(q == NULL){
        BT = p;
        return ;    
    }        
    while(q->lchild != p && q->rchild != p){
        if(x < q->val){
            if(q->lchild){
                q = q->lchild;    
            }    
            else{
                q->lchild = p;
            }        
        }    
        else{
            if(q->rchild){
                q = q->rchild;    
            }    
            else{
                q->rchild = p;    
            }
        }
    }
    return;
}
```

删除操作：<br>
删除操作就稍微有点复杂，删除到某个根节点，还得考虑剩下的左右子树的合并问题.<br>
如果只是删除叶子节点，那就简单，直接删除即可，若是删除到某个根节点，则就要考虑左右子树的合并问题。<br>
由于这种二叉树的性质已经决定了，所以合并在逻辑上并不是太难，难就难在用代码去实现。
**左子树直接到被删除的节点的位置，即与被删除的父节点相接，右子树接到左子树的最右端。这样做会增加树的高度，一般不可取，所以都是采用删除结点的前驱结点替换的方法**

==故操作应为将删除节点替换成左子树最右端节点，然后删除最右端节点即可。==
```
bool delete_BST(pnode p, int x) //返回一个标志，表示是否找到被删元素 
{
    bool find = false;
    pnode q;
    p = BT;
    while(p && !find){  //寻找被删元素 
        if(x == p->val){  //找到被删元素 
            find = true;    
        }    
        else if(x < p->val){ //沿左子树找 
            q = p;
            p = p->lchild;    
        }
        else{   //沿右子树找 
            q = p;
            p = p->rchild;    
        }
    }
    if(p == NULL){   //没找到 
        cout << "没有找到" << x << endl;    
    }
    
    if(p->lchild == NULL && p->rchild == NULL){  //p为叶子节点 
        if(p == BT){  //p为根节点 
            BT = NULL;    
        }
        else if(q->lchild == p){   
            q->lchild = NULL;
        }        
        else{
            q->rchild = NULL;    
        }
        free(p);  //释放节点p 
    }
    else if(p->lchild == NULL || p->rchild == NULL){ //p为单支子树 
        if(p == BT){  //p为根节点 
            if(p->lchild == NULL){
                BT = p->rchild;    
            }    
            else{
                BT = p->lchild;    
            }
        }    
        else{
            if(q->lchild == p && p->lchild){ //p是q的左子树且p有左子树 
                q->lchild = p->lchild;    //将p的左子树链接到q的左指针上 
            }    
            else if(q->lchild == p && p->rchild){
                q->lchild = p->rchild;    
            }
            else if(q->rchild == p && p->lchild){
                q->rchild = p->lchild;    
            }
            else{
                q->rchild = p->rchild;
            }
        }
        free(p);
    }
    else{ //p的左右子树均不为空 
        pnode t = p;
        pnode s = p->lchild;  //从p的左子节点开始 
        while(s->rchild){  //找到p的前驱，即p左子树中值最大的节点 
            t = s;   
            s = s->rchild;    
        }
        p->val = s->val;   //把节点s的值赋给p 
        if(t == p){
            p->lchild = s->lchild;    
        }    
        else{
            t->rchild = s->lchild;    
        }
        free(s); 
    }
    return find;
}
```

查找操作：<br>
根据要查找的数值大小，来遍历左右子树。
```
pnode search_BST(pnode p, int x)
{
    bool solve = false;//标志判断位，判断是否为要寻找的节点
    while(p && !solve){
        if(x == p->val){
            solve = true;    
        }    
        else if(x < p->val){
            p = p->lchild;    
        }
        else{
            p = p->rchild;    
        }
    }
    if(p == NULL){
        cout << "没有找到" << x << endl;    
    } 
    return p;
}
```
## 平衡二叉树
它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。常用的算法有红黑树，AVL树。本处以AVL为例。
##### 平衡因子
左子树的深度与右子树深度的差。即一棵平衡二叉树AVL的平衡因子只有-1，0，1。
在构建平衡二叉树AVL树时，若插入的下一节点使得树不平衡，且**平衡因子为正**，此时就应该把树进行**右旋（顺时针旋转）**。若平衡因子为负，则进行左旋（逆时针旋转）

##### 平衡二叉树的实现算法
在构建这个数据结构的特征是，除了有data还要添加一个结点的平衡因子bf
```
//右旋代码,以p为根进行右旋处理
void R_Rotate(BiTree *p){
    BiTree L ;
    L = (*P)->lchild;
    (*p)->lchild = L->rchild;
    L->rchild = (*p);
    //此时L结点成为根节点，原来的结点成为根结点的右节点
    
}
```
左旋代码也一样，同理可以推出，这里便不做太多详细的说明。在进行左旋，右旋之前，要先确定此树添加节点后是否会破坏平衡性（判断bf的数值）

## 深度扩展——平衡二叉树中的红黑树
##### 性质
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在**二叉查找树**强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
- 性质1. 节点是红色或黑色。
- 性质2. 根是黑色。
- 性质3. 所有叶子都是黑色（叶子是NIL节点）。
- 性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)
- 性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（保证了红色结点一定存在）
- 注： nil 节点就是空节点
![红黑树](http://img.alicdn.com/tps/TB10UXfLFXXXXaxXXXXXXXXXXXX-450-217.png)
- 典型的用途是实现关联数组，例如实现容器类，实现尽快的插入删除，查找。

##### 操作
对于红黑树的操作，若是插入，删除操作也会导致红黑树不平衡，违反性质。故红黑树有其自有的一套**自平衡**操作。

插入操作：先按照二叉排序树的方式增加结点，并将新节点设置成红色，然后再进行自平衡操作。
插入操作的自平衡分为以下几种情形<br>
1. 情形一：该树为空树，直接插入根结点的位置，违反性质1，把节点颜色有红改为黑即可。
2. 情形二：插入节点N的父节点P为黑色，不违反任何性质，无需做任何修改。（P为黑色好说若为红色，则就比较复杂了）
3. 
3. 如果==父节点P和叔父节点U二者都是红色==，(此时新插入节点N做为P的左子节点或右子节点都属于情形3,这里仅显示N做为P左子的情形)则我们可以将它们两个==重绘为黑色并重绘祖父节点G为红色==*(用来保持性质4)*。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上**递归**地进行上述情形的整个过程（*把G当成是新加入的节点进行各种情形的检查*）。比如，G为根节点，那我们就直接将G变为黑色（情形1）；如果G不是根节点，而它的父节点为黑色，那符合所有的性质，直接插入即可（情形2）；如果G不是根节点，而它的父节点为红色，则递归上述过程（情形3）。<br>
![image](https://pic002.cnblogs.com/images/2011/330710/2011120116425251.png)
递归调用这个方法，将父节点转换成情形二的情况，然后再祖父节点进行递归调用，知道祖父结点为根结点。

4. ==父节点P是红色而叔父节点U是黑色或缺少==，**新节点N是其父节点的左子节点**，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对==祖父节点G的一次右旋转==; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色(如果P和G都是红色就违反了性质4，所以G必须是黑色)。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。
![image](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png)
右旋变换后，再进行颜色的变化，保证变换前后对应结点位置的颜色不变。
5. 父节点P是红色而叔父节点U是黑色或缺少，并且**新节点N是其父节点P的右子节0点**而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次==左旋转==（直接对父节点进行左旋操作）调换新节点和其父节点的角色; 接着，我们按情形4处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。
![image](https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png)
情形1-5，操作逐渐变得复杂，都要想办法把复杂的操作通过旋转变形，转化为较简单的情形，然后再操作
 
##### 删除操作
关于删除操作就不在这进行详细的叙述了，可以参考下这篇博客：
[红黑树的删除操作](https://www.cnblogs.com/maybe2030/p/4732377.html)



#### 平衡二叉树小总结
保证了在数的高度在极端的情况，也有好的删除，插入查找的效率。O（lgn）n为树的节点数量



## B-树
这并不是二叉树，这是一种多路搜索树，用来存储排序后的序列，最大的优点在于加快存速度，B-树为系统最优化大块数据的读和写操作。
##### 查找方法

根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

##### 性质
- 定义任意非叶子结点最多只有M个儿子；且M>2；

- 根结点的儿子数为[2, M]；

- 除根结点以外的非叶子结点的儿子数为[M/2, M]；

- 每个结点存放至少M/2-1（取上整）和至多**M-1**个关键字；（至少2个关键字）
- 非叶子结点的关键字个数=指向儿子的指针个数-1；
- 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子结点位于同一层；


![image](https://img-blog.csdn.net/20170327104002676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
如图就是一棵B-树

##### 操作
操作会略显复杂一点，因为要满足B-树的性质定义，在插入节点时，根据节点的数值，看看是否符合定义，若符合就直接插入，不然就要进行节点的分类，构造新的节点，再把原来的替换进去。
下面举例说明：
![image](https://img-blog.csdn.net/20170327144017199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
我们把30这个数字插入进去，会发现：
![image](https://img-blog.csdn.net/20170327144136527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![image](https://img-blog.csdn.net/20170327144332013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
此时就要进行分裂变形
![image](https://img-blog.csdn.net/20170327144946478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU2NDQyMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## B+树
##### 性质
- 非叶子结点的子树指针与关键字个数相同；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
- 为所有叶子结点增加一个链指针；
- **所有关键字**都在叶子结点出现，且有序；
- 最后一定是在叶子节点命中
- 非常适用文件索引

