# 拓扑排序
#### 拓扑排序介绍
对一个==有向无环图==(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将**G中所有顶点排成一个线性序列**，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则==在u线性序列中出现在v之前==。u到v所经过的所有结点构成的序列就是一个拓扑序列。<br>
&nbsp;&nbsp;拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某些工程执行后才可以执行。即要求一些活动必须得在另一些活动开始之前就要执行。为了形象地反映出整个工程中各个子工程(活动)之间的先后关系，可用一个有向图来表示，图中的顶点代表活动(子工程)，图中的有向边代表活动的先后关系，即有向边的起点的活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称AOV网。 <br>
&nbsp;&nbsp;==一个AOV网应该是一个有向无环图==(若有环则很容易构成死锁)，**即不应该带有回路**，因为若带有回路，则回路上的所有活动都无法进行（对于数据流来说就是死循环）。在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，**使得每个活动的所有前驱活动都排在该活动的前面**，我们把此序列叫做拓扑序列(Topological order)，==由AOV网构造拓扑序列的过程叫做拓扑排序(Topological sort)。AOV网的拓扑序列不是唯一的==，满足上述定义的任一线性序列都称作它的拓扑序列。

## 拓扑排序的实现思路
- 在有向图中选一个没有前驱的顶点（**入度为0的顶点**）并且输出
- 从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）
- 重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。

> 若所以的顶点都能输出，则输出的是一个拓扑序列，且这个图不存在环。
> 

## 拓扑排序的代码实现
本处借助了一个栈来保存入度为0的结点信息。删除某节点对应的边就把边头结点对应的顶点的入度-1就可以，若到0，则表示其没有入度，符合要求的结点。
```
/* 拓扑排序，若GL无回路，则输出拓扑排序序列并返回1，若有回路返回0。 */
Status TopologicalSort(GraphAdjList GL)
{    
	EdgeNode *e;    
	int i,k,gettop;   
	int top=0;  /* 用于栈指针下标  */
	int count=0;/* 用于统计输出顶点的个数  */    
	int *stack;	/* 建栈将入度为0的顶点入栈  */   
	stack=(int *)malloc(GL->numVertexes * sizeof(int) );    

	for(i = 0; i<GL->numVertexes; i++)                
		if(0 == GL->adjList[i].in) /* 将入度为0的顶点入栈 */         
			stack[++top]=i;    
	while(top!=0)    
	{        
		gettop=stack[top--];        
		printf("%d -> ",GL->adjList[gettop].data);        
		count++;        /* 输出i号顶点，并计数 */        
		for(e = GL->adjList[gettop].firstedge; e; e = e->next)        
		{            
			k=e->adjvex;            
			if( !(--GL->adjList[k].in) )  /* 将i号顶点的邻接点的入度减1，如果减1后为0，则入栈 */                
				stack[++top]=k;        
		}
	}   
	printf("\n");   
	if(count < GL->numVertexes)        
		return ERROR;    
	else       
		return OK;
}
```

除了上文所描述的算法去实现拓扑排序之外，还可以利用DFS，图的深度优先遍历。上文算法是寻找入度为0的结点。而DFS是寻找出度为0的结点，类似于上文算法的逆过程。它每次都沿着一条路径一直往下搜索，知道某个顶点没有了出度时，就停止递归，往回走，所以我们就用DFS的这个思路，我们可以得到一个有向无环图的拓扑序列。**二者在同一个结点得到的拓扑序列是相反的**。

至于DFS实现拓扑排序这里不陈述太多，只是需要把visit函数在递归结束时调用即可。