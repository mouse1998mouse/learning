## 滑动窗口
>滑动窗口，可以用来解决一些查找满足一定条件的**连续区间的性质**（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。

通用做法:
- 维护两个指针
- 当窗口内的元素未达到题目条件时，右指针右移，探索未知的区间来满足条件。
- 当窗口内的元素达到题目条件时，左指针右移，压缩区间，使窗口尽可能短得满足题目条件。

具体模板如下：
```
int n = nums.size();
    int ans = 0;
    // 记录窗口内的元素及其个数，非必要
    map<int, int> um;
    // l：窗口左边界； r：窗口右边界
    int l = 0, r = 0;
    // r 指针负责探索新的区间，直到搜索到nums的某末尾
    while (r < n) {
        um[r]++;
        // 如果区间不满足条件，l指针右移，窗口收缩
        while(区间 [l, r] is Invalid) {
            um[l]--;
            l++;
        }
        // 此处处理结果, deal with(ans, 区间[l, r])
        res = max(ans, r - l + 1); // 或者res = min(ans, r - l + 1);
        // 右指针右移，继续搜索
        r++;
    }

```

遇到字符串排列问题，例如求子串，那也不是全都是用dfs，起码要考虑到滑动窗口跟字典的组合。字典==（哈希表其实是一个很好用的工具）==

## 前缀和解题思路
当数组存在负数，滑动窗口不适用的时候，就可以考虑使用前缀和了。
> 前缀和的思路就是：当我们循环数组到下标N时，需要用到数组前N-1项的计算的结果（这里不一定非要是和，也可能是积等），此时我们就该考虑是否应该通过计算数组循环过程中的累计值的方式简化解题，如此便有了前缀和的解题思想。

前缀和的解题思想：
1. 题目明确要求不允许使用额外空间的，直接原地修改数组
2. 不限制空间复杂度时，最好额外开辟空间计算，避免数据污染
3. 计算时如果每次只需要获取前一次的累计结果，可以通过数组的方式存储每次获取数组末尾元素的值
4. 如果每次计算需要获取前几次或更多次的结果进行对比时，推荐**哈希表**的方式，这样可以压缩时间复杂度

例题：
给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。

思路：
初始化一个空的哈希表和pre_sum=0的前缀和变量
设置返回值ret = 0，用于记录满足题意的子数组数量
循环数组的过程中，通过原地修改数组的方式，计算数组的累加和
将当前累加和减去整数K的结果，在哈希表中查找是否存在
如果存在该key值，证明以数组某一点为起点到当前位置满足题意，ret加等于将该key值对应的value
判断当前的累加和是否在哈希表中，若存在value+1，若不存在value=1
最终返回ret即可


```
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:

        n = len(nums)
        res = 0
        numSum = 0
        dic = {}
        dic[0] = 1

        for num in nums:
            numSum = numSum + num
            res = dic.get(numSum-k,0) + res
            if numSum in dic:
                dic[numSum] = dic[numSum] + 1
            else:
                dic[numSum] = 1
        return res
        
假如 numSum - k = a
例如a在dic中，那么子数组就为numSum - a所剩下的数组。

numSum为前i项数组的和。所以可以用这种方式去构造子数组。用前缀和做key，和的数量做value

```

