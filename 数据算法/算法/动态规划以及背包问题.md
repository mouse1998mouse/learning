## 动态规划以及背包问题

公式：**状态转换方程 f[i,j] = Max{ f[i-1,j-Wi]+Pi( j >= Wi ),  f[i-1,j] }**

> 代码方式

```
for(j=1; j<=m; j=j+1) // 第一个阶段
   xn[j] = 初始值;

 for(i=n-1; i>=1; i=i-1)// 其他n-1个阶段
   for(j=1; j>=f(i); j=j+1)//f(i)与i有关的表达式
     xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};

t = g(x1[j1:j2]); //由子问题的最优解求解整个问题的最优解的方案

print(x1[j1]);

for(i=2; i<=n-1; i=i+1）
{  
     t = t-xi-1[ji];

     for(j=1; j>=f(i); j=j+1)
        if(t=xi[ji])
             break;
}

```
有时候需要注意循环的方向。根据规模小的子问题计算规模大的子问题，因此计算子问题的顺序为先计算规模小的子问题，后计算规模大的子问题，需要注意循环遍历的方向。
dp的大小一般**为target+1**
### 背包问题技巧：
##### 1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；

```
for num in nums:
    for i in range(target, nums-1, -1):
        # for k in range(1,k+1) 其中k是这个物品的个数（如果是多重背包则要加上这个循环）
        
#   这只是一维度的情况，如果是升高一维度，那么只需要再多加一个循环，因为是0/1背包，所以新加的循环，我们也要从大到小进行遍历。类似题目可以为：

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。
每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。

for i in range(len(nums):
    v = v[i] #i个物品的价值
    m = M[i] #i个物品的重量
    for i in range(V, v-1, -1)：
        for k in range(M,m-1，-1)：
            dp[j][k]=max(dp[j][k],dp[j-v][k-m]+w)


```
##### 2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。

```
for num in nums:
    for i in range(nums, target+1):
```

##### 3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。

```
for i in range(1, target+1):
    for num in nums:
        dp[i] += dp[i-num]
```

#### 背包问题的内循环 
```
dp[i] += dp[i-num]  # 组合问题公式
dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1) # 最大最小值公式
dp[i] = dp[i] or dp[i-num] True或者False模式
```
#### 背包问题（零钱的兑换）
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。
例如：输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        coins.sort()
        dp = [0] + [10001] * amount  # dp[0] = 0
        for num in coins:
            for j in range(num,amount+1):
                dp[j] = min(dp[j], dp[j - num] + 1)

        if dp[-1] == 10001:
            return -1
        else:
            return dp[-1]
#个数肯定不会大于10001
```

#### 动态规划的核心
当前的最优解=max（以前子序列的最优解，当前决策得到的解）
这是求解股票最大值的好办法。

##### 连续子序列最大值
要注意核心的关键点，在于边界值为0（子序列和的值为0）的时候，这个时候就要求我们重新开始定位子序列。

#### 礼物的最大值
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

> 动态规划一定要找到临界条件，构造子序列的最优解。例如本题的临界条件为：我们只可以从上到下或者从左到右移动，所以有以下判断

![max_value](6A2983C227F141A39C79D97340B61B1C)

然后根据这个思路，我们就可以做出解答。
```
import numpy
class Solution:
    def maxValue(self, grid: List[List[int]]) -> int:

        

        raw,col = numpy.array(grid).shape
        
        # 将起始行列进行初始化
        for i in range(1,col):
            grid[0][i] = grid[0][i] + grid[0][i-1]
        for i in range(1,raw):
            grid[i][0] = grid[i][0]+grid[i-1][0]

        for i in range(1,raw):
            for j in range(1,col):
                grid[i][j] = grid[i][j] + max(grid[i-1][j],grid[i][j-1])
        
        return grid[raw-1][col-1]
```

#### 动态规划另一种题型——数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法？例如12258，12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"。
> 这也是一种动态规划的题型，虽然这不是一种找最优解的题型，但是我们仍然可以根据动态规划的一般套路，找临界值。由题意可知，组合方式有两种，要么就一个字符，要么就两个字符进行组合，F（i）的路径只可以从F（i-1）跟F（i-2）获取，由此可以构建动态规划方程.

具体思路可以看下图：
![数字转成字符串](https://pic.leetcode-cn.com/e231fde16304948251633cfc65d04396f117239ea2d13896b1d2678de9067b42-Picture1.png)

```
class Solution:
    def translateNum(self, num: int) -> int:
        
        s = str(num)
        length = len(s)
        result = [0]*length
        result[0] = 1
        if length <= 1:
            return result[0]
        if int(s[0:2]) <=25:
            result[1] = 2
        else:
            result[1] = 1
        
        
        for i in range(2,length):
            result[i] = result[i] + result[i-1]
            if int(s[i-1:i+1]) <= 25 and int(s[i-1]) != 0:
                result[i] = result[i] + result[i-2]
        #print(result)
        return result[-1]

            


```

## 三角形的最小路径和
给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1。
例如：输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2<br>
  3 4<br>
 6 5 7<br>
4 1 8 3<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

>动态规划，主要还是要找前后的递推关系。
错误解法：
我一开始使用了错误的解法，寻找行与行之间的关系，例如：
```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:

        n = len(triangle)
        result = [0] * n
        result[0] = triangle[0][0]
        index = 0

        for i in range(1,n):
            if triangle[i][index] > triangle[i][index+1]:
                index = index + 1
            result[i] = result[i-1]+triangle[i][index]

        return result[-1]
        
    # 这种方式不全，会浪费剩下一半的空间，没有遍历，导致进入一个局部的最优解，不能代表全局最优解。

```
其实不应该这么做，我们应该定位的具体的点，定位具体的i,j找一下到i,j位置的最小值，最后返回第I行的最小值就好了。
```
# 正确的代码应该这样写
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        for i in range(1,n):
            for j in range(len(triangle[i])):
                if j == 0:
                    triangle[i][j] = triangle[i-1][j] + triangle[i][j]
                if j > 0:
                    if j < len(triangle[i-1]):
                        triangle[i][j] = min(triangle[i-1][j-1],triangle[i-1][j]) + triangle[i][j]
                    else:
                        triangle[i][j] = triangle[i-1][j-1] + triangle[i][j]

        return min(val for val in triangle[n-1])



```
## 有关二维动态规划的套路
求两个数组或者是字符串的最长公共子序列问题，肯定是要用上动态规划的。首先要明白，子序列可以是不连续的，而子数组（子串）是连续的

>单个数组或者字符串要用动态规划时，可以把动态规划dp[i]定义为定义为 nums[0:i] 中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i][j] ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。

#### 例题
求两个字符串的最长公共子序列
跟子串的区别在于：子串必须连续所以断开必须从0开始，而子序列不需要连续，断开不需要从0开始。因为子串是连续的，所以记录最后一个元素的位置可以得到子串，而子序列不行

我们来看状态转移方程怎么写。
- 当text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i][j] = dp[i - 1][j - 1] + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。
- 当text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dp[i][j] 应该是 dp[i - 1][j] 和 dp[i][j - 1] 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。
- 

代码如下图所示：
```
n = len(s1)
m = len(s2)
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(1,n+1):
        for j in range(1,m+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:   ## else后一段是求子序列用的，如果是子串  那基本上不需要这一段  然后直接用max记录最大值
                dp[i][j] = max(dp[i-1][j],dp[i][j-1])
    print(dp[n][m])
    
    
# 如果还要求最长公共子序列的值，则可以：
num = dp[i][j]
        i, j = m, n
        while i >= 1 and j >= 1:
            if s1[i-1] == s2[j-1]:
                res += s1[i-1]
                i -= 1
                j -= 1
            elif dp[i][j-1] > dp[i-1][j]:
                j -= 1
            else: i -= 1
        if not res: return -1
        return res[::-1]
#由dp出发，找长的那个方向
```



