# 回溯算法
> 一般要画出对应的树形图，然后将树形图进行编程实现，因为要考虑到回溯，所以一般使用递归可以很好的实现

>在回溯时，如果时间太长了就可以使用import functools，然后在函数上使用注解：
@functools.lru_cache(None)。functools.lru_cache 是非常实用的装饰器，它实现了备忘（memoization）功能。这是一 项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。

看到 全排列，或者 枚举全部解，等类似的 搜索枚举类型题，基本就是 回溯 没跑了。
注：求字符串的子串题目不能用dfs，因为dfs得到的是字符串的子序列。

回溯问题三要素：
1. 有效答案，什么时候return
2. 回溯范围。回溯到哪里
3. 剪枝条件，什么时候需要剪枝
### 回溯算法跟深度优先遍历
**回溯法** 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。
<br>
**深度度优先搜索算法**（DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将**回溯** 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

> 回溯算法用于搜索一个问题所有的解，通常利用深度优先遍历实现，一定要画出对应的树形图

回溯算法的一般套路：
```
def backtrace(choices, path):
    if 满足条件：#满足条件
        res.append(path[:])
        return
    for choice in choices: #回溯范围
        path.append(choice)
        backtrace(choices, path)
        path.pop()

```

下面我来给一个模板思路
```
字符串的全排列代码：
class Solution:
    def permutation(self, s: str) -> List[str]:
        if not s: return 
        s=list(sorted(s))
        res=[]
        def helper(s,tmp):
            if not s: res.append(''.join(tmp))
            for i,char in enumerate(s):
                if i>0 and s[i]==s[i-1]:
                    continue
                helper(s[:i]+s[i+1:],tmp+[char])
        helper(s,[])
        return res

数组的全排列代码
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res=[]
        nums.sort()
        def helper(nums,temp):
            if not nums:
                res.append(temp)
            for i in range(len(nums)):
                if i>0 and nums[i]==nums[i-1]:
                    continue
                helper(nums[:i]+nums[i+1:],temp+[nums[i]])
        helper(nums,[])
        return res
```


### 简单例题
##### 二进制手表
二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。例如，输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]

> 思路分析：其实就是采用回溯的方法进行做题，然后将不满足条件的分支剪掉。

总体思路:
1. 在10个灯中选num个灯点亮，如果选择的灯所组成的时间已不合理（小时超过11，分钟超过59）就进行剪枝
2. 也就是从0到10先选一个灯亮，再选当前灯的后面的灯亮，再选后面的灯的后面的灯亮，一直到num个灯点满

具体思路:
1. 为了方便计算，分别设置了小时数组和分钟数组
2. 递归的四个参数分别代表：剩余需要点亮的灯数量，从索引index开始往后点亮灯，当前小时数，当前分钟数
3. 每次进入递归后，先判断当前小时数和分钟数是否符合要求，不符合直接return
4. for循环枚举点亮灯的情况，从index枚举到10，每次枚举，
    - 减少一个需要点亮的灯数量num - 1
    - 从当前已点亮的灯后面选取下一个要点亮的灯 i + 1
    - 在hour中增加当前点亮灯的小时数，如果i大于3，当前灯是分钟灯而不是小时灯，则加上0个小时
    - 在minute中增加当前点亮灯的分钟数，如果i没有大于3，当前灯是小时灯而不是分钟灯，则加上0分钟
5. 当剩余需要点亮的灯数量为0的时候，已枚举完一种情况，根据题目要求的格式加到res列表中
6. 返回res

```
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        hours = [1, 2, 4, 8, 0, 0, 0, 0, 0, 0]
        minutes = [0, 0, 0, 0, 1, 2, 4, 8, 16, 32]
        res = []
        def backtrack(num, index, hour, minute):
            if hour > 11 or minute > 59:
                return
            if num == 0:
                res.append('%d:%02d' % (hour, minute))
                return
            for i in range(index, 10):
                backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i])
        
        backtrack(turnedOn, 0, 0, 0)
        return res
```

#### 矩阵中的路径
定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

![示例图](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

> 思路：本题是典型的矩阵搜索问题，可以考虑用DFS+剪枝的思路

- 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
- 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝

解析
- 递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。
- 终止条件：
返回 falsefalse ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
返回 truetrue ： k = len(word) - 1 ，即字符串 word 已全部匹配。
- 递推工作：
标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
- 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。
- 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。
返回值： 返回布尔量 res ，代表是否搜索到目标字符串。

代码如下：
```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # i,j是矩阵的元素，K是word中的索引
        def dfs(i,j,k):
            if not 0<= i < len(board) or not 0<=j <len(board[0]) or board[i][j] != word[k]:
                return False
            if k == len(word) -1:
                return True
            board[i][j] = '' # 标记为访问过的节点
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = word[k] # 复原

            return res

        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```
####  下面简单说说BFS
BFS是广度优先搜索， 他可以明确的帮我们定位到下一层，按照层次来进行遍历。

其中模板如下
###### 不需要明确遍历到了哪一层
```
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)
```
###### 需要明确遍历到了具体层
```
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;
```
#### 二叉排序树与双向循环链表

