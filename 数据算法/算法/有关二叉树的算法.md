# 二叉树的遍历

### 二叉树的层序遍历
层序遍历要借用队列实现。考虑有两重循环，输出每层节点的值。

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        #跟结点入queue
        queue = [root]
        res = []
        while queue:
            res.append([node.val for node in queue])
            #存储当前层的孩子节点列表
            ll = []
            #对当前层的每个节点遍历 这点要注意区分，如果只是层序遍历输出，可没有这一段
            for node in queue:
                #如果左子节点存在，入队列
                if node.left:
                    ll.append(node.left)
                #如果右子节点存在，入队列
                if node.right:
                    ll.append(node.right)
            #后把queue更新成下一层的结点，继续遍历下一层
            queue = ll
        return res
```


## 利用先序遍历跟中序遍历构造二叉树

要根据结点之间的前后关系进行判断.
先序遍历的结点信息是根左右
中序遍历的结点信息是左根右。
先序遍历确定根节点的位置，然后中序遍历划分了左右子树
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        idx = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:1 + idx], inorder[:idx])
        root.right = self.buildTree(preorder[1 + idx:], inorder[idx + 1:])

        return root
```


同理 利用后序遍历+中序遍历构造二叉树可以像以下的方式处理:
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        # 中：左根右
        # 后：左右根

        if not inorder or not postorder:
            return None
        root = TreeNode(postorder[-1])
        idx = inorder.index(root.val)

        root.left = self.buildTree(inorder[:idx], postorder[:idx])
        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])

        return root
```

## 二叉排序树的最近公共祖先

跟树有关，做这种题目一般可以考虑到深度优先搜索（dfs）

而且这道题给定了二叉排序树，所以我们要利用好二叉排序树的定义。这时候跟据节点的大小，我们可以用迭代法进行做题。

*公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先*

根据以上定义，若 rootroot 是 p,qp,q 的 最近公共祖先 ，则只可能为以下情况之一：

- p 和 q 在 rootroot 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
- p = rootp，且 qq 在 rootroot 的左或右子树中；
- q = rootq，且 pp 在 rootroot 的左或右子树中。

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root :
            return None
        if p.val > q.val: 
            p, q = q,p 
        while root:
            if root.val < p.val: # p,q 都在 root 的右子树中
                root = root.right # 遍历至右子节点
            elif root.val > q.val: # p,q 都在 root 的左子树中
                root = root.left # 遍历至左子节点
            else: break

        return root
# 或者我们可以采用递归的思路
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        return root


```

如果是一个普通的树，则难点在于如何书写递归函数，不妨这样思考：

假设我们从跟结点开始，采用 DFS 向下遍历，如果当前结点到达叶子结点下的空结点时，返回空；如果当前结点为 p 或 q 时，返回当前结点；

这样，当我们令 left = self.lowestCommonAncestor(root.left, p, q) 时，如果在左子树中找到了 p 或 q，left 会等于 p 或 q，同理，right 也是一样；

然后我们进行判断：如果 left 为 right 都不为空，则为情况 1；如果 left 和 right 中只有一个不为空，说明这两个结点在子树中，则根节点到达子树再进行寻找。



```
if not root or root == p or root ==q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        if not right:
            return left
        return root
```






