# 贪心算法

> 当前局部最优表示全局最优。关键是选择合适的贪心策略

贪心算法的求解步骤：
1. 将问题分为若干个子问题
2. 找出合适的==贪心策略==
3. 求解每一个子问题的最优解
4. 将局部最优解堆叠成全局最优解




#### 最长上升子序列问题
给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

##### 解法
题目要我们判断是否存在长度为 3 的上升子序列，问题可以转换为求 numsnums 的最长上升子序列（LIS 问题）的长度。在遍历每个数 nums[i] 的同时，维护一个具有单调性的 f 数组，其中 f(len) 代表长度为 len 的最长上升子序列最小结尾元素为 x，可以证明 f 数组具有单调性，因此每次可以通过二分找到小于 nums[i] 的最大下标，来作为 nums[i] 的前一个数。 ==单调数组的重要性==


代码:
```
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        if not nums:
            return False
        f1 = float("inf")
        f2 = float("inf")

        for num in nums:
            if num > f2 :
                return True
            elif num > f1 and num < f2:
                f2 = num 
            elif num < f1:
                f1 = num 

        return False

```

#### 移掉K位数字
给定一个以字符串表示的非负整数  num，移除这个数中的 k 位数字，使得剩下的数字最小。
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

###### 解法
为了实现最优的解法，所以我们最好进行一次遍历，那么对于每个元素，我们都要判断他应该是保留还是舍弃。问题来了，如何判断这个元素是要保留还是舍弃？这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a > b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小。
所以这时候我们可以用这样的思路：
1. 从左到右遍历
2. 对于遍历到了元素，我们选择保留或者丢弃。按照题目的意思，我们要对齐k个元素
3. 我们可以根据这个元素的大小选择性的丢弃前面相邻位置的元素（左边的元素）


```
stack = []
        remain = len(num) - k
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
        return ''.join(stack[:remain]).lstrip('0') or '0'

```




