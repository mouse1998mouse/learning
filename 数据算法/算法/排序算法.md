# 快速排序：
前后遍历，两两比较，通常取第一位元素为基准值，适用于整体无序的情况。一次快排可唯一确定一个元素的最终位置（基准元素）。

快速排序是选取一个“哨兵”(pivot)，将小于pivot放在左边，把大于pivot放在右边，分割成两部分，并且可以固定pivot在数组的位置，在对左右两部分继续进行排序。

> 从后往前寻找

### 例题
#### 例题一：把数组排成最小整数
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
实例： 输入: [3,30,34,5,9]
输出: "3033459"

> 思路分析：我们可以先将数组整体变得有序再拼接。按照题意，设数组 numsnums 中任意两数字的字符串为 x 和 y，若x+y>y+x,那么y应该在x的前面，我们确定好这种比较大小的规则后就可以进行排序了。

这道题首先要明确比较规则，知道比较规则就可以进行排序了，不单单局限于一种排序方法。


```
# 此处我用的是快排进行处理
class Solution:
    def minNumber(self, nums: List[int]) -> str:
        # 修改字符串排序的大小比较的方法。先排好序，直接拼接，例如快排，就是一种两两比较的方法
        def quick_sort(l , r):
            if l >= r: return
            i, j = l, r
            while i < j:
                while strs[j] + strs[l] >= strs[l] + strs[j] and i < j: j -= 1
                while strs[i] + strs[l] <= strs[l] + strs[i] and i < j: i += 1
                strs[i], strs[j] = strs[j], strs[i]
            strs[i], strs[l] = strs[l], strs[i]
            quick_sort(l, i - 1)
            quick_sort(i + 1, r)

        strs = []
        for num in nums:
            strs.append(str(num))
        quick_sort(0,len(strs) -1)
        return "".join(strs)

```

# 堆排序
堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。构造堆后可以很方便找前K个最大元素，或者最小元素。
算法实现步骤：
1. 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)；
2. 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素；
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素；
4. 如此反复进行交换、重建、交换，直到整个序列有序。

> 自顶向下遍历，自下而上建堆。

```
# 调整堆
# 迭代写法
def shift_down(self, nums, i, end):
    tmp = nums[i]
    while 2 * i + 1 <= end:
        child = 2 * i + 1
        if child != end and nums[child + 1] > nums[child]:
            child += 1
        if tmp < nums[child]:
            nums[i] = nums[child]
            i = child
        else:
            break
    nums[i] = tmp


def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        for i in range(n//2 - 1, -1, -1):
            self.shift_down(nums, i, n - 1)
        
        i = n - 1
        while i > 0:
            nums[i], nums[0] = nums[0], nums[i]
            i -= 1
            self.shift_down(nums, 0, i)
        return nums


```
1. 先用tmp暂存索引为i的元素
2. 其左子节点索引为 2 * i + 1
3. 如果左子节点并非是堆中最后一个元素，并且右子节点的值比左子节点更大，索引 + 1，让父节点和右子节点比较
4. 父节点值tmp和子节点值比较，如果父节点值更小，父节点和子节点交换位置，也就是父节点下沉
5. 一旦父节点值tmp比子节点大了，说明该位置以下的节点已经都比它小了，不用下沉了，break结束循环
6. 最后不要忘了把当前i位置元素赋值为tmp



注：可以看这个链接：https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/


## 归并排序
> 归并排序其实是一个分治问题。在涉及到分治法的时候，可以考虑到归并排序的做法

归并排序的示意图如下：
![image](https://pic.leetcode-cn.com/1614274007-rtFHbG-Picture2.png)

```
# 合并A B两个有序序列
def merge(a, b):
    c = []
    h = j = 0
    while j < len(a) and h < len(b):
        if a[j] < b[h]:
            c.append(a[j])
            j += 1
        else:
            c.append(b[h])
            h += 1

    if j == len(a):
        for i in b[h:]:
            c.append(i)
    else:
        for i in a[j:]:
            c.append(i)

    return c
    
# 进行归并排序
def merge_sort(lists):
    if len(lists) <= 1:
        return lists
    middle = len(lists)/2
    left = merge_sort(lists[:middle])
    right = merge_sort(lists[middle:])
    return merge(left, right)

```

#### 有关归并排序的例题：
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

分析：求解逆序对的问题， 实际上就是一个关于归并排序的问题。

```
# 逆序对的问题解答
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        def merge_sort(l,r):
            if l >= r: return 0
            # 递归划分
            m = (l + r) // 2
            res = merge_sort(l, m) + merge_sort(m + 1, r)
            # 合并阶段
            i, j = l, m + 1
            tmp[l:r + 1] = nums[l:r + 1]
            for k in range(l, r + 1):
                if i == m + 1:
                    nums[k] = tmp[j]
                    j += 1
                elif j == r + 1 or tmp[i] <= tmp[j]:
                    nums[k] = tmp[i]
                    i += 1
                else:
                    nums[k] = tmp[j]
                    j += 1
                    res += m - i + 1 # 统计逆序对
            return res
        tmp = [0] * len(nums)
        return merge_sort(0, len(nums) - 1)
```


