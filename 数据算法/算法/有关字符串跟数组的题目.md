# 有关字符串或者数组的问题

### 回文字符串以及中心扩散法的使用
给定一个字符串 s ，返回 其重新排列组合后可能构成的所有回文字符串，并去除重复的组合 。

你可以按 任意顺序 返回答案。如果 s 不能形成任何回文排列时，则返回一个空列表。

> 回文子串，前后是一样的，这样的规律让人很容易想到中心扩展。如果是回文字符串，我们先找到位于中间的那个字符。中间的那个字符可能是“”或者是“X”，我们从中间依次往两边扩散即可。

如果一个字符串是回文的，那么其拥有奇数数量的字符一定不会大于1 .
```
counter = collections.Counter(s)
        index = 0
        odd_char = "#"
        for key in counter:
            if counter[key] % 2 != 0 :
                index = index + 1
                odd_char = key

        # print(counter)
        if index > 1:  # 如果奇数数量的字符个数大于1，肯定构不成回文字符串
    
            return []
            
# 接下来使用中心扩散法
if index == 1:
            mid = mid + odd_char
            counter[odd_char] = counter[odd_char] - 1
        res = []

        def dfs(cur,target_len):
            if len(cur) > target_len:
                return
            if len(cur) == target_len:
                res.append(cur[:])
                return
            for key,value in counter.items():
                if value > 0 :
                    counter[key] = counter[key] - 2
                    dfs(key+cur+key,target_len) # 在mid两边进行添加，中心扩散
                    counter[key] = counter[key] + 2
        
        dfs(mid,len(s))
        return res
            
```

下面再来看一道题，用中心扩展法求最大回文子串。
给你一个字符串 s，找到 s 中最长的回文子串。
> 中心扩展的本质就是：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。

```
class Solution:
    def expandAroundCenter(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)
            left2, right2 = self.expandAroundCenter(s, i, i + 1)
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]
```


### 差分数组
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k​​​​​​​ 个更新的操作。
其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。
请你返回 k 次操作后的数组。
> 如果知道每个元素都比前一个元素大多少，以及第一元素的值，我们就可以在O（n）的空间内求出数组所有的和。这就是差分的思路

a<sub>start</sub> 比前一个元素多了inc  

a<sub>end + 1 </sub> 比前一个元素少了inc

```
n = length
        ################ 典型差分，上下台阶的思想，"出租车上下车问题"
        f = [0 for _ in range(n)]   #差分数组
        #### 差分
        for start, end, diff in updates:
            f[start] += diff
            if end + 1 < n:
                f[end + 1] -= diff
        #### 整理
        for i in range(1, n):
            f[i] += f[i-1]  ### 关键在于这一步
        return f

对于出租车上下车问题也是一样的解题思路
```
