# 基础语法
> go语言的指针表示跟C++ 比较相似

在go语言中，使用panic跑出异常
使用recover来捕获异常，但是这个函数只有在defer关键字中才有用，defer关键字是延时执行的功能。

### 指针
指针的用法跟C语言类似。 

```
& ：从一个普通变量中取得内存地址
* ：当*在赋值操作符（=）的右边，是从一个指针变量中取得变量值，当*在赋值操作符（=）的左边，是指该指针指向的变量
```

#### select 跟switch
select 与 switch 原理很相似，但它的使用场景更特殊，学习了本篇文章，你需要知道如下几点区别：

1. select 只能用于 channel 的操作(写入/读出/关闭)，而 switch 则更通用一些；
2. select 的 case 是随机的，而 switch 里的 case 是顺序执行；
3. select 要注意避免出现死锁，同时也可以自行实现超时机制；
4. select 里没有类似 switch 里的 fallthrough 的用法；
5. select 不能像 switch 一样接函数或其他表达式。
6. 写了select，养成好的习惯，要写default关键字。
7. 

# 面向对象
go语言使用结构图struct来代替了其他语言的class，在go语言中放弃了大量面向对象的特性，他并没有继承的概念。
结构体的使用方式为：
```
type 结构体名 struct {
    属性名   属性类型
    属性名   属性类型
    ...
}
```

在go语言中，我们无法在结构体内部定义方法，因为不存在类的概念，所以我们要在结构体外部定义方法，然后用实例绑定的方式，例如：
```
// 定义一个名为Profile 的结构体
type Profile struct {
    name   string
    age    int
    gender string
    mother *Profile // 指针
    father *Profile // 指针
}

// 定义一个与 Profile 的绑定的方法
func (person Profile) FmtProfile() {
    fmt.Printf("名字：%s\n", person.name)
    fmt.Printf("年龄：%d\n", person.age)
    fmt.Printf("性别：%s\n", person.gender)
}

func main() {
    // 实例化
    myself := Profile{name: "小明", age: 24, gender: "male"}
    // 调用函数
    myself.FmtProfile()
}

其中FmtProfile 是方法名，而(person Profile) ：表示将 FmtProfile 方法与 Profile 的实例绑定。我们把 Profile 称为方法的接收者，而 person 表示实例本身，它相当于 Python 中的 self，在方法内可以使用 person.属性名 的方法来访问实例属性。
```

如果我们想要在方法内部改变实例的属性，必须要==用指针作为方法==的接受者，即改变结构体当中某个变量的值，此时我们可以类比java中的set方法。
```
// 重点在于这个星号: *
func (person *Profile) set_age(age int) {
    person.age = age
}
```

### 结构体的“继承“
这个继承不是真的继承，在go语言中并不支持继承，但是我们可以使用组合的方法实现类似继承的效果。
具体来说，在go语言中，把一个结构体嵌入到另一个结构体中，这就称之为组合。
具体请看下面的例子，这里有一个表示公司的结构体与一个表示公司职员的结构体
```
type company struct {
    companyName string
    companyAddr string
}

type staff struct {
    name string
    age int
    gender string
    position string
}

如果要将他们关联起来，但是在 Go 中没有类的概念，只有组合，你可以将 company 这个 结构体嵌入到 staff 中，做为 staff 的一个匿名字段，staff 就直接拥有了 company 的所有属性了。

type staff struct {
    name string
    age int
    gender string
    position string
    company   // 匿名字段
}
```

### 结构体的实例化
```
第一种，直接实例化
xm := Profile{
        name: "小明",
        age: 18,
        gender: "male",
    }
    
第二种，使用new关键字
xm := new(Profile) // 等价于: var xm *Profile = new(Profile)

第三种 使用&   （我一般推荐前两种）
var xm *Profile = &Profile{}
```

### make跟new的区别
new 函数只能传递一个参数，可以分配内存，设置零值，**返回一个指针**
make主要是用来为切片，map或者chan类型分配内存跟初始化一个对象。make返回的是对象本身而不是一个引用。
### 内部方法与外部方法
在 Go 语言中，函数名的首字母大小写非常重要，它被来实现控制对方法的访问权限。
- 当方法的首字母为大写时，这个方法对于所有包都是Public，其他包可以随意调用
- 当方法的首字母为小写时，这个方法是Private，其他包是无法访问的。
- 

## 接口跟多态
在go语言中，**接口是方法签名的集合**，指定了一个类型应该具有的方法，并由该类型决如何实现这些方法。在go语言中，我们使用**type关键字**来定义接口
```
type Phone interface{
    call()  // 接口方法
}
```

在go语言中，实现接口，只要实现了这个接口里面所有的方法就可以，不像jave里面还要使用implement关键字。继续上诉例子，我们只需要

```
type Nokia struct {
    name string
}

// 接收者为 Nokia, 实现了call 方法，相当于实现了Phone接口
func (phone Nokia) call() {
    fmt.Println("我是 Nokia，是一台电话")
}
```

###  接口实现多态
我们是通过接口来实现多态，，具体的请看下面的例子
```
//定义物品接口
type Good interface {
    settleAccount() int
    orderInfo() string
}

//先定义一个商品（Good）的接口，意思是一个类型或者结构体，只要实现了settleAccount() 和 orderInfo() 两个方法，那这个类型/结构体就是一个商品。

type Phone struct {
    name string
    quantity int
    price int
}

type FreeGift struct {
    name string
    quantity int
    price int
}

// Phone
func (phone Phone) settleAccount() int {
    return phone.quantity * phone.price
}
func (phone Phone) orderInfo() string{
    return "您要购买" + strconv.Itoa(phone.quantity)+ "个" +
        phone.name + "计：" + strconv.Itoa(phone.settleAccount()) + "元"
}

// FreeGift
func (gift FreeGift) settleAccount() int {
    return 0
}
func (gift FreeGift) orderInfo() string{
    return "您要购买" + strconv.Itoa(gift.quantity)+ "个" +
        gift.name + "计：" + strconv.Itoa(gift.settleAccount()) + "元"
}
//实现了 Good 接口要求的两个方法后，手机和赠品在Go语言看来就都是商品（Good）类型了。这时候我们实例化两个商品
iPhone := Phone{
    name:     "iPhone",
    quantity: 1,
    price:    8000,
}
earphones := FreeGift{
    name:     "耳机",
    quantity: 1,
    price:    200,
}
// 我们创建啊一个购物车来存放这些商品
goods := []Good{iPhone, earphones}

//最后定义一个方法来计算购物车的订单金额
func calculateAllPrice(goods []Good) int {
    var allPrice int
    for _,good := range goods{
        fmt.Println(good.orderInfo())
        allPrice += good.settleAccount()
    }
    return allPrice
}
```

接口断言
t, ok:= i.(T)  用这种方式来实现接口断言。这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其值给 t，并且此时 ok 的值 为 true，表示断言成功。
#### 将接口 转换为其他类型
```
p1 := new(pig)
var a Walker = p1  //这是一个walker接口
p2 := a.(*pig)    // 将接口转变为pig类型
fmt.Printf("p1=%p p2=%p", p1, p2)
```
#### 空接口
对于接口而言，都包含两个属性，一个是值一个是类型。然而对于空借口来说，这两者都是nil。我们会在什么时候使用空接口呢？
1. 使用interface{}作为类型声明一个实例，这个实例可以承载任意类型的值
2. 让函数接收任意类型的值，可以使用空接口


###  反射
使用反射，我们可以获取一个对象的类型，属性以及方法
在go语言的世界里，有两种类型非常重要：type跟value
1. reflect.Type ：以接口的形式存在
2. reflect.Value： 以结构体的形式存在

反射的三大定律：
1. 反射可以将接口类型变量 转换为“反射类型对象”；
2. 反射可以将 “反射类型对象”转换为 接口类型变量；
3. 如果要修改 “反射类型对象” 其类型必须是 可写的；


#### 第一定律
为了实现从接口变量中到反射对象的转换，需要提到两个重要的方法：
1. reflect.TypeOf(i) ：获得接口值的类型
2. reflect.ValueOf(i)：获得接口值的值
这两个方法就返回了前面提到的两个接口对象（type跟value）

由于 TypeOf 和 ValueOf 两个函数接收的是 interface{} 空接口类型，而 Go 语言函数都是值传递，因此Go语言会将我们的类型隐式地转换成接口类型。


#### 第二定律
跟第一定律相反，第二定律从反射对象到接口变量进行转换，使用Interface方法，返回一个interface类型的变量
注意：只有 Value 才能逆向转换，而 Type 则不行，这也很容易理解，如果 Type 能逆向，那么逆向成什么呢？

#### 第三定律
反射只是原始对象的一个映射，第三定律引出了一个settable的概念，在反射进行的修改最终也是会还原到真实的原始对象中。
回到反射上，当你使用 reflect.Typeof 和 reflect.Valueof 的时候，如果传递的不是==接口变量的指针==，反射世界里的变量值始终将只是真实世界里的一个拷贝，你对该反射对象进行修改，并不能反映到真实世界里。
因此在反射的规则中：
1. 不是接收变量指针创建的反射对象，不具备可写性
2. 是否具备可写性，可以使用CanSet（）来获取
3. 对不具备『可写性』的对象进行修改，是没有意义的，也认为是不合法的，因此会报错。

# go语言中的并发编程
#### 函数声明
go语言是编译语言，所以函数的编写顺序是无关的
我们声明函数，只需要使用func关键字就可以，列如
```
func 函数名（参数列表）（返回值列表）{
}

列如：
func sum(a int, b int) int{
    return a+b
}

多个参数：
使用 ...int，表示一个元素为int类型的切片，用来接收调用者传入的参数。
// 使用 ...类型，表示一个元素为int类型的切片，这是一个语法糖
func sum(args ...int) int {
    var sum int
    for _, v := range args {
        sum += v
    }
    return sum
```

#### 函数类型
函数类型是一种很特殊的类型，表示所有拥有同样的入参类型和返回值类型的函数集合
例如：
```
type Greeting func(name string) string // 定义了一个名叫Greeting的函数类型
```
如果一个函数只接受一个参数，且类型为string，并且返回值也只有一个并且是string，那么通过以下的方式将其转换成Greeting类型
```
func english(name string) string {
    return "Hello, " + name
}

// 转换成 Greeting 类型的函数对象
greet := Greeting(english)
// 或者
var greet Greeting = english
```
其中greet为Greeting类型的对象，他也将拥有Greeting类型的所有方法。


### go语言中的协程
go语言中不需要我们学习如何创建进程池，线程池，也不需要知道什么情况下使用多线程，什么时候使用多进程。因为你没得选，也不需要选，它原生提供的 goroutine （也即协程）已经足够优秀，能够自动帮你处理好所有的事情，而你要做的只是执行它，就这么简单。

回归到本值，一个gorountine（协程）就是一个函数。使用关键字go
```
//执行一个普通函数 
func()

//开启一个协程执行这个函数
go func()
```

main的地位相当于主线程，当main函数执行完成后，这个线程也就结束了，其中剩下的协程也就结束了 

*创建协程是需要时间的*

简单来实现先并发的效果：
```
func mygo(name string) {
    for i := 0; i < 10; i++ {
        fmt.Printf("In goroutine %s\n", name)
        // 为了避免第一个协程执行过快，观察不到并发的效果，加个休眠
        time.Sleep(10 * time.Millisecond)
    }
}

func main() {
    go mygo("协程1号") // 第一个协程
    go mygo("协程2号") // 第二个协程
    time.Sleep(time.Second)
}
```

### 信道机制
如果说 goroutine 是 Go语言程序的并发体的话，那么 channel（信道） 就是 它们之间的通信机制。信道实际上是一个队列机制。可以类比java中的一个缓冲区

##### 定义
每个信道只能传递一种数据类型，声明的时候要指定数据类型，然后使用make函数初始化，关键字：chan
```
var 信道实例 chan 信道类型
信道实例 = make(chan 信道类型)

== 信道实例 := make(chan 信道类型)

例如：
pipline := make(chan int) //创建了一个int类型的信道,此时信道的容量是0
```

信道的操作无非是两种，发送数据和接受数据。使用符号
```
// 使用符号<-
// 往信道中发送数据
pipline<- 200

// 从信道中取出数据，并赋值给mydata
mydata := <-pipline

// 最后记得要关闭信道
close(pipline)

但是如果关闭一个已经关闭的信道，那是会报错的，所以我们要进行判断,
x, ok := <-pipline
当从信道中读取数据时，可以有多个返回值，其中第二个可以表示 信道是否被关闭，如果已经被关闭，ok 为 false，若还没被关闭，ok 为true。

```
在我们使用make函数初始化信道时，可以初始化信道的容量，默认是0，如果信道的容量是0，那意味着这个信道没有缓冲区，即我们在信道里无法存储数据，这意味着，接收端必须先于发送端准备好，以确保你发送完数据后，有人立马接收数据，否则发送端就会造成阻塞。

make函数：
1. 第一个参数：必填，指定信道类型
2. 第二个参数：选填，不填默认为0，指定信道的容量（可缓存多少数据）

一般情况下，我们定义的信道都是双向信道，有时候我们需要单向信道（只发送、只接收）要怎么做呢？ 可以使用如下定义：
```
//定义只读信道
var pipline = make(chan int)
type Receiver = <-chan int // 关键代码：定义别名类型
var receiver Receiver = pipline

// 定义只写信道
var pipline = make(chan int)
type Sender = chan<- int  // 关键代码：定义别名类型
var sender Sender = pipline

区别在于是chan<- 还是 <-chan。
<-chan：表示这个信道，只能从里发出数据，对于程序来说就是只读
chan<- 表示这个信道，只能从外面接收数据，对于程序来说就是只写
```

信道的遍历，可以使用for跟range来实现。但是遍历信道时， 一定要确保信道处于关闭状态。
```
// 信道的操作
func fibonacci(mychan chan int){
	n:=cap(mychan)
	x,y :=1,1
	for i:=0;i<n;i++{
		mychan <- x
		x, y = y, x+y
	}
	// 信道写完后就关闭
	close(mychan)
}
func main(){
	//go mytest("我是一号")
	//go mytest("我是二号")
	//time.Sleep(time.Second)

	pipline := make(chan int ,10)
	go fibonacci(pipline)
	for k:= range pipline{
		fmt.Println(k)
	}
}
```

当信道里面的数据已经满了时，此时再继续往里面发送数据会阻塞整个程序，考虑到这个特性，我们可以用他来当程序的锁。类比os里面的信号量机制
```
// 由于 x=x+1 不是原子操作
// 所以应避免多个协程对x进行操作
// 使用容量为1的信道可以达到锁的效果
func increment(ch chan bool, x *int) {
    ch <- true
    *x = *x + 1
    <- ch
}

func main() {
    // 注意要设置容量为 1 的缓冲信道
    pipline := make(chan bool, 1)

    var x int
    for i:=0;i<1000;i++{
        go increment(pipline, &x)
    }

    // 确保所有的协程都已完成
    // 以后会介绍一种更合适的方法（Mutex），这里暂时使用sleep
    time.Sleep(time.Second)
    fmt.Println("x 的值：", x)
}
```

几个注意事项：
1. 关闭一个未初始化的 channel 会产生 panic
2. 重复关闭同一个 channel 会产生 panic
3. 向一个已关闭的 channel 发送消息会产生 panic
4. 从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已被读取，则会读取到该类型的零值。

5.从已关闭的 channel 读取消息永远不会阻塞，并且会返回一个为 false 的值，用以判断该 channel 是否已关闭（x,ok := &lt;- ch）
6. 关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息
7. channel 在 Golang 中是一等公民，它是线程安全的，面对并发问题，应首先想到 channel。


### waitGroup
之前为了让程序执行完，都是使用了time.Sleep的形式，但是在实际使用中，我们并不推荐这种方式。我们可以使用信道来标记完成。
注意：不要通过共享内存来通信，而是要通过通信来共享内存。
例如 我们可以定义一个信道，在任务完成后，往信道写入true，只要主协程获取到true，就认为子协程执行完毕。

**第二种方式就是使用waitGroup**
```
var 实例名 sync.WaitGrounp
```
实例完成后， 就可以使用它的几个方法：
add:初始值为0，你传入的值会往计数器上加，这里直接传入子协程的数量
Done：当某个子协程完成后，可以调用这个方法，计数器会减1，通常可以使用defer调用。
wait： 阻塞当前协程，直到计数器为0
```
例子如下：

import (
    "fmt"
    "sync"
)

func worker(x int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i < 5; i++ {
        fmt.Printf("worker %d: %d\n", x, i)
    }
}

func main() {
    var wg sync.WaitGroup

    wg.Add(2)
    go worker(1, &wg)
    go worker(2, &wg)

    wg.Wait()
}
```
> 实现一主多子的协程协作方式，推荐使用 sync.WaitGroup。

### 互斥锁跟读写锁
如果信道解决不了的问题，不得不使用共享内存来实现，那就只能使用Go中的锁机制了。锁基本上都在sync包， 这里有两个很重要到了锁类型，分别是Mutex跟RWMutex
1. Mutex：互斥锁
2. RWMutex：读写锁

在go语言中，加锁的方式为：
```
//定义一个锁
// 第一种
var lock *sync.Mutex
lock = new(sync.Mutex)

// 第二种
lock := &sync.Mutex{}

例：
func add(count *int, wg *sync.WaitGroup,lock *sync.Mutex) {
	for i := 0; i < 10000; i++ {
		lock.Lock()   //加锁
		*count = *count + 1
		lock.Unlock()  // 释放锁
	}
	wg.Done()
}

func main(){
	var wg sync.WaitGroup
	lock:=new(sync.Mutex)
	count := 0
	wg.Add(3)
	go add(&count,&wg,lock)
	go add(&count,&wg,lock)
	go add(&count,&wg,lock)
	wg.Wait()
	fmt.Println(count)

}

```

互斥锁很简单，但是要注意以下几点：
-  同一个协程里， 不要在没有解锁的时候进行加锁
-  同一个协程里，不要对已解锁的锁进行再次解锁。
-  加了锁后不要忘记解锁，必要时可以使用defer语句

互斥锁容易造成资源浪费的情况，所以为了提高并发量，我们引入了读写锁RWMutex。为了保证数据的安全，他规定了当有人还在读取数据时，不允许更新数据（写锁会堵塞）。

为了保证程序的效率，多个人（线程）读取数据时，互不影响，不会造成堵塞。
下面用例子来说明读写锁的用法
在RWMutex中提供了两种方法来表示两种锁
- 读锁：调用RLock方法开启，调用RUnlock释放
- 写锁：调用 Lock 方法开启锁，调用 Unlock 释放锁（和 Mutex类似）
```
// 第一种
var lock *sync.RWMutex
lock = new(sync.RWMutex)

// 第二种
lock := &sync.RWMutex{}

func main() {
    lock := &sync.RWMutex{}
    lock.Lock()

    for i := 0; i < 4; i++ {
        go func(i int) {
            fmt.Printf("第 %d 个协程准备开始... \n", i)
            lock.RLock()
            fmt.Printf("第 %d 个协程获得读锁, sleep 1s 后，释放锁\n", i)
            time.Sleep(time.Second)
            lock.RUnlock()
        }(i)
    }

    time.Sleep(time.Second * 2)

    fmt.Println("准备释放写锁，读锁不再阻塞")
    // 写锁一释放，读锁就自由了
    lock.Unlock()

    // 由于会等到读锁全部释放，才能获得写锁
    // 因为这里一定会在上面 4 个协程全部完成才能往下走
    lock.Lock()
    fmt.Println("程序退出...")
    lock.Unlock()
}
```






